# GermanPOSTagConverter

A tool, developed in the research project [hermA](https://www.herma.uni-hamburg.de/en.html), for the conversion between part-of-speech (POS) and morphological tag file formats (with corresponding tagsets) used by different tagging tools for German.

# System Requirements

The software has been tested with Windows 10 and Linux. Being written in Java, it should run on any platform Java supports; you will need a Java runtime to run the software. It has been developed and tested with Java 8, but newer versions may also work.

# Command Line

The program expects two positional command-line arguments, preceded by option-value pairs:

	[option1 value1 option2 value2 ...] input_file output_file

The available options are:

* `-input-format` specifies the format of the input file, that is, the format to be converted from. This option must be present. For possible values see below.
* `-input-charset` specifies the charset (encoding) of the input file. The value has to be a charset name supported by Java; for Java 8, a list can be found [here](https://docs.oracle.com/javase/8/docs/technotes/guides/intl/encoding.doc.html). If this option is left out, the input charset is assumed to be UTF-8.
* `-output-format` specifies the format of the output file, that is, the format to be converted to. This option must be present. For possible values see below.
* `-output-charset` specifies the charset (encoding) of the output file. The value has to be a charset name supported by Java; for Java 8, a list can be found [here](https://docs.oracle.com/javase/8/docs/technotes/guides/intl/encoding.doc.html). If this option is left out, the output file is written in UTF-8 encoding.

Possible values for `-input-format` and `-output-format` are:

* `rftagger`
  
  A text file format where each line is either empty (denoting a sentence boundary) or consists of the word form, followed by a TAB character, followed by the POS tag. This format is associated with RFTagger (see below).
  
* `conllx`
  
  The [CoNLL-X](https://ilk.uvt.nl/~emarsi/download/pubs/14964.pdf) format: Each line is either empty (denoting a sentence boundary) or consists of fields separated by TAB characters. See below for details.
  
* `tsv`
  
  A text file format where each line is either empty (denoting a sentence boundary) or consists of fields separated by TAB characters; the columns are different from those in CoNLL-X (see below). This format is mainly intended to be used in conjunction with manual annotation (it can easily be copied into or from Excel spreadsheets).

# Formats and Tagsets

## RFTagger

The RFTagger format (`rftagger`) is named this way because it is the output format of [RFTagger](https://www.cis.uni-muenchen.de/~schmid/tools/RFTagger/) and for this format the converter implements conversion from or to a tagset in the style of the RFTagger tagset described [here](https://www.sketchengine.eu/german-rftagger-part-of-speech-tagset/), with the following differences:

* Pre- and postpositions (`APPR` and `APPO`) have a case marker in the original RFTagger tagset (for example `APPR.Acc`) and are sometimes lexicalized (`APPR.in`). Such markers are ignored when reading the format, and not present in the output when writing it (`APPR` instead of `APPR.Acc`).
* The gender feature of pronouns (`PRO`), like the person feature, also accepts a hyphen-minus (`-`). Unlike the asterisk (`*`), which denotes value ambiguity, the hyphen-minus is supposed to indicate that this feature is systematically not applicable. While the person feature is only applicable to personal and reflexive pronouns, the gender feature is *not* applicable only to reflexive pronouns. When converting to other formats, pronoun person or gender features set to `-` are treated as if they were not present at all.
* This converter provides two new symbol types: `SYM.Pun.Apos` for apostrophes and `SYM.Pun.Other` for other punctuation symbols, as opposed to `SYM.Other.XY` for non-punctuation symbols (see below for a description of the conversion implications).
* Participles (`VPP`) have a subtype feature in the original RFTagger tagset, `Prp` (present participle) or `Psp` (past participle). However, as present participles are always either `ADJA` or `ADJD`, this feature can never have the value `Prp` and is therefore redundant. It is ignored when reading the format and left out when writing it.

Although the tags generated by the converter are sometimes different from the tags of the original tagset, all tags that are possible in the original tagset should be accepted when reading a file in this format. However, some linguistically impossible combinations (such as `VINF.Aux.zu` or `VIMP.Mod.1.Sg`) will not be accepted.

## CoNLL-X

The CoNLL-X format (`conllx`) has ten columns, but this converter only takes the first, second, fifth and sixth column into account. The first column is the word index: Words are usually sequentially numbered within each sentence, starting with one. (The other formats do not have such a numbering, so the converter generates it when converting to CoNLL-X.) The second column is the word itself, the fifth column is the POS tag and the sixth column contains the morphological features.

POS tags are expected to be from the <i lang="de">Stuttgart-Tübingen-Tagset</i> (STTS). For articles merged with prepositions, both `APPRART` and `APPART` are accepted, but `APPRART` is output. For pronominal adverbs, both `PROAV` and `PAV` are accepted, but `PAV` is output. `$LRB` (left round bracket) is accepted as an alias of `$(`, the tag for sentence-internal punctuation.

Morphological features in the sixth column are separated by pipe characters (`|`) and consist of a name and a value, separated by `=`, like in `tense=pres`. Features are not ordered. Supported feature names are:

* `case`
* `number`
* `gender`
* `degree`
* `person`
* `tense`
* `mood`

Possible values of the case feature are:

* `nom` (nominative)
* `gen` (genitive)
* `dat` (dative)
* `acc` (accusative)
* `*` (ambiguous)

Possible values of the number feature are:

* `sg` (singular)
* `pl` (plural)
* `*` (ambiguous)

Possible values of the gender feature are:

* `masc` (masculine)
* `fem` (feminine)
* `neut` (neuter)
* `*` (ambiguous)

Possible values of the degree feature are:

* `pos` (positive)
* `comp` (comparative)
* `sup` (superlative)

Possible values of the person feature are:

* `1`
* `2`
* `3`

Possible values of the tense feature are:

* `pres` (morphological present)
* `past` (morphological past)

Possible values of the mood feature are:

* `ind` (indicative)
* `subj` (subjunctive)

## TSV

The TSV format (`tsv`) has nine columns:

1. the word itself
2. the POS tag
3. gender
4. case
5. number
6. degree
7. person
8. tense
9. mood

POS tags and feature values are treated like those for the CoNLL-X format, see above. For features that are not present the respective column stays empty, that is, two TAB characters follow each other.

# Conversion

In addition to the conversion between the different file formats, the converter also has to convert between the two tagsets (STTS with its features and the RFTagger tagset). Occasionally they differ in the level of granularity, but are generally equivalent. Some tags that are atomic in STTS are represented as coarser categories with subtypes in the RFTagger tagset. Sometimes these subtypes provide an even more fine-grained distinction. On the other hand, the distinction between `PIAT` (indefinite pronoun replacing an article) and `PIDAT` (indefinite pronoun used together with an article) in STTS is not made in the RFTagger tagset.

The converter converts tags according to the following table:

<table>
	<tr>
		<th>STTS</th>
		<th/>
		<th>RFTagger</th>
		<th style="text-align:left;">Remarks</th>
	</tr>
	<tr>
		<td><code>ADJA</code></td>
		<td>↔</td>
		<td><code>ADJA</code></td>
		<td></td>
	</tr>
	<tr>
		<td><code>ADJD</code></td>
		<td>↔</td>
		<td><code>ADJD</code></td>
		<td></td>
	</tr>
	<tr>
		<td><code>ADV</code></td>
		<td>↔</td>
		<td><code>ADV</code></td>
		<td></td>
	</tr>
	<tr>
		<td><code>APPO</code></td>
		<td>↔</td>
		<td><code>APPO</code></td>
		<td></td>
	</tr>
	<tr>
		<td><code>APPR</code></td>
		<td>↔</td>
		<td><code>APPR</code></td>
		<td></td>
	</tr>
	<tr>
		<td><code>APPRART</code></td>
		<td>↔</td>
		<td rowspan="2"><code>APPRART</code></td>
		<td rowspan="2"><code>APPRART</code> and <code>APPART</code> are different names of the same tag</td>
	</tr>
	<tr>
		<td><code>APPART</code></td>
		<td>→</td>
	</tr>
	<tr>
		<td><code>APZR</code></td>
		<td>↔</td>
		<td><code>APZR</code></td>
		<td></td>
	</tr>
	<tr>
		<td><code>ART</code></td>
		<td>↔</td>
		<td><code>ART</code></td>
		<td>see remarks below</td>
	</tr>
	<tr>
		<td><code>CARD</code></td>
		<td>↔</td>
		<td><code>CARD</code></td>
		<td></td>
	</tr>
	<tr>
		<td><code>FM</code></td>
		<td>↔</td>
		<td><code>FM</code></td>
		<td></td>
	</tr>
	<tr>
		<td><code>ITJ</code></td>
		<td>↔</td>
		<td><code>ITJ</code></td>
		<td></td>
	</tr>
	<tr>
		<td><code>KOKOM</code></td>
		<td>↔</td>
		<td><code>CONJ.Comp</code></td>
		<td></td>
	</tr>
	<tr>
		<td><code>KON</code></td>
		<td>↔</td>
		<td><code>CONJ.Coord</code></td>
		<td></td>
	</tr>
	<tr>
		<td><code>KOUI</code></td>
		<td>↔</td>
		<td><code>CONJ.SubInf</code></td>
		<td></td>
	</tr>
	<tr>
		<td><code>KOUS</code></td>
		<td>↔</td>
		<td><code>CONJ.SubFin</code></td>
		<td></td>
	</tr>
	<tr>
		<td><code>NE</code></td>
		<td>↔</td>
		<td><code>N.Name</code></td>
		<td></td>
	</tr>
	<tr>
		<td><code>NN</code></td>
		<td>↔</td>
		<td><code>N.Reg</code></td>
		<td></td>
	</tr>
	<tr>
		<td><code>PAV</code></td>
		<td>↔</td>
		<td rowspan="2"><code>PROADV.Dem</code></td>
		<td rowspan="2"><code>PAV</code> and <code>PROAV</code> are different names of the same tag</td>
	</tr>
	<tr>
		<td><code>PROAV</code></td>
		<td>→</td>
	</tr>
	<tr>
		<td><code>PDAT</code></td>
		<td>↔</td>
		<td><code>PRO.Dem.Attr</code></td>
		<td></td>
	</tr>
	<tr>
		<td><code>PDS</code></td>
		<td>↔</td>
		<td><code>PRO.Dem.Subst</code></td>
		<td></td>
	</tr>
	<tr>
		<td><code>PIAT</code></td>
		<td>↔</td>
		<td rowspan="2"><code>PRO.Indef.Attr</code></td>
		<td rowspan="2">both <code>PIAT</code> and <code>PIDAT</code> are mapped to <code>PRO.Indef.Attr</code>; <code>PRO.Indef.Attr</code> is always mapped to <code>PIAT</code></td>
	</tr>
	<tr>
		<td><code>PIDAT</code></td>
		<td>→</td>
	</tr>
	<tr>
		<td><code>PIS</code></td>
		<td>↔</td>
		<td><code>PRO.Indef.Subst</code></td>
		<td></td>
	</tr>
	<tr>
		<td><code>PPER</code></td>
		<td>↔</td>
		<td><code>PRO.Pers.Subst</code></td>
		<td></td>
	</tr>
	<tr>
		<td><code>PPOSAT</code></td>
		<td>↔</td>
		<td><code>PRO.Poss.Attr</code></td>
		<td></td>
	</tr>
	<tr>
		<td><code>PPOSS</code></td>
		<td>↔</td>
		<td><code>PRO.Poss.Subst</code></td>
		<td></td>
	</tr>
	<tr>
		<td><code>PRELAT</code></td>
		<td>↔</td>
		<td><code>PRO.Rel.Attr</code></td>
		<td></td>
	</tr>
	<tr>
		<td><code>PRELS</code></td>
		<td>↔</td>
		<td><code>PRO.Rel.Subst</code></td>
		<td></td>
	</tr>
	<tr>
		<td><code>PRF</code></td>
		<td>↔</td>
		<td><code>PRO.Refl.Subst</code></td>
		<td></td>
	</tr>
	<tr>
		<td><code>PTKA</code></td>
		<td>↔</td>
		<td><code>PART.Deg</code></td>
		<td></td>
	</tr>
	<tr>
		<td><code>PTKANT</code></td>
		<td>↔</td>
		<td><code>PART.Ans</code></td>
		<td></td>
	</tr>
	<tr>
		<td><code>PTKNEG</code></td>
		<td>↔</td>
		<td><code>PART.Neg</code></td>
		<td></td>
	</tr>
	<tr>
		<td><code>PTKVZ</code></td>
		<td>↔</td>
		<td><code>PART.Verb</code></td>
		<td></td>
	</tr>
	<tr>
		<td><code>PTKZU</code></td>
		<td>↔</td>
		<td><code>PART.Zu</code></td>
		<td></td>
	</tr>
	<tr>
		<td><code>PWAT</code></td>
		<td>↔</td>
		<td><code>PRO.Inter.Attr</code></td>
		<td></td>
	</tr>
	<tr>
		<td><code>PWAV</code></td>
		<td>↔</td>
		<td><code>PROADV.Inter</code></td>
		<td></td>
	</tr>
	<tr>
		<td><code>PWS</code></td>
		<td>↔</td>
		<td><code>PRO.Inter.Subst</code></td>
		<td></td>
	</tr>
	<tr>
		<td rowspan="4"><code>TRUNC</code></td>
		<td>←</td>
		<td><code>TRUNC.Adj</code></td>
		<td rowspan="4">all RFTagger subtypes of <code>TRUNC</code> are mapped to <code>TRUNC</code> in STTS; <code>TRUNC</code> in STTS is mapped to <code>TRUNC.-</code> in the RFTagger tagset</td>
	</tr>
	<tr>
		<td>←</td>
		<td><code>TRUNC.Noun</code></td>
	</tr>
	<tr>
		<td>←</td>
		<td><code>TRUNC.Verb</code></td>
	</tr>
	<tr>
		<td>↔</td>
		<td><code>TRUNC.-</code></td>
	</tr>
	<tr>
		<td><code>VAFIN</code></td>
		<td>↔</td>
		<td><code>VFIN.Aux</code></td>
		<td></td>
	</tr>
	<tr>
		<td><code>VAIMP</code></td>
		<td>↔</td>
		<td><code>VIMP.Aux</code></td>
		<td></td>
	</tr>
	<tr>
		<td><code>VAINF</code></td>
		<td>↔</td>
		<td><code>VINF.Aux.-</code></td>
		<td></td>
	</tr>
	<tr>
		<td><code>VAPP</code></td>
		<td>↔</td>
		<td><code>VPP.Aux</code></td>
		<td></td>
	</tr>
	<tr>
		<td><code>VMFIN</code></td>
		<td>↔</td>
		<td><code>VFIN.Mod</code></td>
		<td></td>
	</tr>
	<tr>
		<td><code>VMINF</code></td>
		<td>↔</td>
		<td><code>VINF.Mod.-</code></td>
		<td></td>
	</tr>
	<tr>
		<td><code>VMPP</code></td>
		<td>↔</td>
		<td><code>VPP.Mod</code></td>
		<td></td>
	</tr>
	<tr>
		<td><code>VVFIN</code></td>
		<td>↔</td>
		<td><code>VFIN.Full</code></td>
		<td></td>
	</tr>
	<tr>
		<td><code>VVIMP</code></td>
		<td>↔</td>
		<td><code>VIMP.Full</code></td>
		<td></td>
	</tr>
	<tr>
		<td><code>VVINF</code></td>
		<td>↔</td>
		<td><code>VINF.Full.-</code></td>
		<td></td>
	</tr>
	<tr>
		<td><code>VVIZU</code></td>
		<td>↔</td>
		<td><code>VINF.Full.zu</code></td>
		<td></td>
	</tr>
	<tr>
		<td><code>VVPP</code></td>
		<td>↔</td>
		<td><code>VPP.Full</code></td>
		<td></td>
	</tr>
	<tr>
		<td rowspan="2"><code>XY</code></td>
		<td>↔</td>
		<td><code>SYM.Other.XY</code></td>
		<td rowspan="2">see remarks below</td>
	</tr>
	<tr>
		<td>↔</td>
		<td><code>SYM.Other.Auth</code></td>
	</tr>
	<tr>
		<td rowspan="3"><code>$.</code></td>
		<td>↔</td>
		<td><code>SYM.Pun.Sent</code></td>
		<td rowspan="3">see remarks below</td>
	</tr>
	<tr>
		<td>↔</td>
		<td><code>SYM.Pun.Colon</code></td>
	</tr>
	<tr>
		<td>↔</td>
		<td><code>SYM.Pun.Cont</code></td>
	</tr>
	<tr>
		<td><code>$,</code></td>
		<td>↔</td>
		<td><code>SYM.Pun.Comma</code></td>
		<td></td>
	</tr>
	<tr>
		<td rowspan="9"><code>$(</code><br/>(<code>$LRB</code>)</td>
		<td>↔</td>
		<td><code>SYM.Other.Aster</code></td>
		<td rowspan="9">see remarks below</td>
	</tr>
	<tr>
		<td>↔</td>
		<td><code>SYM.Pun.Apos</code></td>
	</tr>
	<tr>
		<td>↔</td>
		<td><code>SYM.Paren.Left</code></td>
	</tr>
	<tr>
		<td>↔</td>
		<td><code>SYM.Paren.Right</code></td>
	</tr>
	<tr>
		<td>↔</td>
		<td><code>SYM.Pun.Hyph</code></td>
	</tr>
	<tr>
		<td>↔</td>
		<td><code>SYM.Pun.Slash</code></td>
	</tr>
	<tr>
		<td>↔</td>
		<td><code>SYM.Quot.Left</code></td>
	</tr>
	<tr>
		<td>↔</td>
		<td><code>SYM.Quot.Right</code></td>
	</tr>
	<tr>
		<td>↔</td>
		<td><code>SYM.Pun.Other</code></td>
	</tr>
</table>

STTS does not distinguish between definite and indefinite articles, while the RFTagger tagset does (`ART.Def`, `ART.Indef`). When converting from STTS to RFTagger tags, the converter therefore employs a heuristic to determine whether the article is definite or indefinite: If (the lowercased version of) a word form tagged `ART` starts with a ‘d’, it is considered a definite article, otherwise an indefinite article.

The RFTagger tagset has a very fine-grained tag inventory for punctuation and other symbols, while there are only three tags in STTS: `$.` for sentence-final punctuation, `$,` for commata and `$(` for any other punctuation. The correspondence is only unambiguous for `$,` (which corresponds to `SYM.Pun.Comma`). `$.` corresponds to `SYM.Pun.Sent` in most cases, but colons (`SYM.Pun.Colon`) and ellipses (`SYM.Pun.Cont`) are also often tagged `$.` so all three tags are mapped to `$.` in STTS. In the other direction, the word form is used to determine which tag to convert to; colons (‘:’ U+003A COLON) are converted to `SYM.Pun.Colon`, three dots (‘...’) as well as the ellipsis character (‘…’ U+2026 HORIZONTAL ELLIPSIS) are converted to `SYM.Pun.Cont`, any other token tagged `$.` is converted to `SYM.Pun.Sent`. Even more cases have to be distinguished for `$(`:

<table>
	<tr>
		<th colspan="2" style="text-align:left;">word form</th>
		<th>RFTagger tag</th>
	</tr>
	<tr>
		<td>*</td>
		<td>U+002A ASTERISK</td>
		<td><code>SYM.Other.Aster</code></td>
	</tr>
	<tr>
		<td>'</td>
		<td>U+0027 APOSTROPHE</td>
		<td><code>SYM.Pun.Apos</code></td>
	</tr>
	<tr>
		<td>(</td>
		<td>U+0028 LEFT PARENTHESIS</td>
		<td><code>SYM.Paren.Left</code></td>
	</tr>
	<tr>
		<td>)</td>
		<td>U+0029 RIGHT PARENTHESIS</td>
		<td><code>SYM.Paren.Right</code></td>
	</tr>
	<tr>
		<td>-</td>
		<td>U+002D HYPHEN-MINUS</td>
		<td><code>SYM.Pun.Hyph</code></td>
	</tr>
	<tr>
		<td>/</td>
		<td>U+002F SOLIDUS</td>
		<td><code>SYM.Pun.Slash</code></td>
	</tr>
	<tr>
		<td>`</td>
		<td>U+0060 GRAVE ACCENT</td>
		<td rowspan="2"><code>SYM.Quot.Left</code></td>
	</tr>
	<tr>
		<td>``</td>
		<td>2× U+0060</td>
	</tr>
	<tr>
		<td>''</td>
		<td>2× U+0027 APOSTROPHE</td>
		<td><code>SYM.Quot.Right</code></td>
	</tr>
	<tr>
		<td colspan="2"><i>(anything else)</i></td>
		<td><code>SYM.Pun.Other</code></td>
	</tr>
</table>

The RFTagger tag `SYM.Other.Auth` seems to be intended for the acronyms of news agencies (*dpa*, *afp* etc.), which are tagged `XY` in the Tiger corpus. Therefore, this converter converts `SYM.Other.Auth` to `XY`. In the other direction, `XY` is converted to `SYM.Other.Auth` if the word form of the token consists entirely of Latin characters, and to `SYM.Other.XY` otherwise.